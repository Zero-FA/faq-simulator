<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Apex Trader Funding</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet" />
  <style>
    html, body { height: 100%; font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial; }
    .bubble { border-radius: 1rem; padding: .75rem 1rem; box-shadow: 0 1px 2px rgba(0,0,0,.05); border: 1px solid rgba(0,0,0,.08); }
    .ch-item { cursor: pointer; border-radius: .5rem; padding:.5rem .75rem; display:flex; gap:.5rem; align-items:center;}
    .ch-item.active { background: rgb(30 41 59 / .55); }
    .dot { width:.5rem; height:.5rem; border-radius:9999px; }
  </style>
</head>
<body class="bg-slate-100">
  <div id="root" class="min-h-screen"></div>

  <!-- React + Babel -->
  <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

  <script type="text/babel">
    const { useState, useEffect, useRef } = React;

    // ================= CONFIG =================
    const USE_MOCK = false;
    const COACH_URL = '/api/coach';
    const GRADE_URL = '/api/grader';
    const CHECK_ACCESS_URL = '/api/check-access';

    const CHANNELS = [
      { id: 'platform-setup',       name: '#platform-setup',       file: '/faqs/platform-setup.md',      dot:'bg-indigo-400' },
      { id: 'evaluation-content',   name: '#evaluation-content',   file: '/faqs/evaluation-content.md',  dot:'bg-emerald-400' },
      { id: 'performance-account',  name: '#performance-account',  file: '/faqs/performance-account.md', dot:'bg-pink-400' },
      { id: 'billing',              name: '#billing',              file: '/faqs/billing.md',             dot:'bg-amber-400' },
      { id: 'affiliate-program',    name: '#affiliate-program',    file: '/faqs/affiliate-program.md',   dot:'bg-cyan-400' },
      { id: 'tech-support',         name: '#tech-support',         file: '/faqs/tech-support.md',        dot:'bg-violet-400' },
    ];

    const QUESTIONS_PER_RUN = 5;
    const RUN_SECONDS = 10 * 60; // 10:00

    // ============== HELPERS ==============
    async function fetchFAQMd(channelId){
      const ch = CHANNELS.find(c=>c.id===channelId);
      if(!ch) throw new Error('Unknown channel');
      const r = await fetch(ch.file, { cache:'no-store' });
      if(!r.ok) throw new Error(`Failed to load ${ch.file}: ${r.status}`);
      return await r.text();
    }

    function pickQuestionFromMd(md) {
      if (!md) return "What's the first step to get started?";
      const lines = md.split(/\r?\n/).map(s => s.trim()).filter(Boolean);
      const candidates = lines.filter(s => /^#+\s|^how to|^how do|^what|^where|^when|^do i|^can i/i.test(s));
      const list = candidates.length ? candidates : lines.slice(0, 20);
      const raw = list[Math.floor(Math.random() * list.length)];
      const q = raw.replace(/^#+\s*/, "");
      return /[?.!]$/.test(q) ? q : `${q}?`;
    }

    async function coachAsk({ history, channelId, faqMd }) {
      const channelName = CHANNELS.find(c=>c.id===channelId)?.name || channelId;

      if (USE_MOCK) {
        const q = pickQuestionFromMd(faqMd);
        return { role: 'assistant', content: q };
      }

      const r = await fetch(COACH_URL, {
        method: 'POST',
        headers: { 'Content-Type':'application/json' },
        body: JSON.stringify({ channel: channelName, history, faqMd })
      });

      const txt = await r.text();
      let data;
      try { data = JSON.parse(txt); } catch { throw new Error(`Coach ${r.status}: ${txt}`); }
      if (!r.ok) throw new Error(data?.error || `Coach ${r.status}`);
      return data.reply;
    }

    async function gradeAnswer({ channelId, question, answer, faqMd }) {
      const channelName = CHANNELS.find(c=>c.id===channelId)?.name || channelId;

      const r = await fetch(GRADE_URL, {
        method: 'POST',
        headers: { 'Content-Type':'application/json' },
        body: JSON.stringify({ channel: channelName, question, answer, faqMd })
      });

      const txt = await r.text();
      let data;
      try { data = JSON.parse(txt); } catch { throw new Error(`Grader ${r.status}: ${txt}`); }
      if (!r.ok) throw new Error(data?.error || `Grader ${r.status}`);
      return data;
    }

    function randomId(len=16){
      const arr = new Uint8Array(len);
      (crypto || window.msCrypto).getRandomValues(arr);
      return Array.from(arr).map(b=>b.toString(16).padStart(2,'0')).join('');
    }

    // ================= UI =================
    function Avatar({variant="bot"}) {
      const color = variant==="bot" ? "bg-indigo-500" : "bg-emerald-500";
      return <div className={`w-9 h-9 ${color} text-white rounded-full grid place-items-center font-semibold`}>{variant==="bot"?"C":"T"}</div>;
    }

    function Row({from="bot", text, time}) {
      const isBot = from === "bot";
      return (
        <div className={`flex items-end gap-3 ${isBot ? "" : "justify-end"}`}>
          {isBot && <Avatar variant="bot" />}
          <div className="flex flex-col gap-1 max-w-[70ch]">
            <div className="text-[10px] text-slate-500">{isBot ? "Coach" : "Trainee"} • {time}</div>
            <div className={`bubble ${isBot ? "bg-white" : "bg-emerald-50 border-emerald-200"}`}>{text}</div>
          </div>
          {!isBot && <Avatar variant="user" />}
        </div>
      );
    }

    function App() {
      // Access gate
      const [accessOk, setAccessOk] = useState(false);
      const [codeDraft, setCodeDraft] = useState('');
      const [checking, setChecking] = useState(false);
      const [accessErr, setAccessErr] = useState('');

      // Core app state
      const [channelId, setChannelId] = useState(CHANNELS[0].id);
      const [faqMd, setFaqMd] = useState('');
      const [messages, setMessages] = useState([]);
      const [history, setHistory] = useState([]);
      const [draft, setDraft] = useState('');
      const [started, setStarted] = useState(false);
      const [finished, setFinished] = useState(false);
      const [qCount, setQCount] = useState(0);
      const [grading, setGrading] = useState(null);
      const [typing, setTyping] = useState(false);
      const [secondsLeft, setSecondsLeft] = useState(RUN_SECONDS);

      // Sequential locking
      const [unlockedIdx, setUnlockedIdx] = useState(0);
      const [completedIds, setCompletedIds] = useState(new Set());
      const [notice, setNotice] = useState('');

      const scrollRef = useRef(null);
      const timerRef = useRef(null);
      const now = () => new Date().toLocaleTimeString([], {hour:'2-digit', minute:'2-digit'});

// No restore — always require code on fresh load
useEffect(() => {
  setAccessOk(false);
}, []);

async function handleAccessSubmit(e) {
  e?.preventDefault?.();
  if (!codeDraft.trim()) return;
  setChecking(true);
  setAccessErr('');
  try {
    const r = await fetch(CHECK_ACCESS_URL, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ code: codeDraft.trim() })
    });
    const ok = r.ok;
    const data = await r.json().catch(() => ({}));
    if (!ok || !data?.ok) {
      throw new Error(data?.error || 'Invalid code');
    }
    // Removed localStorage.setItem(...) — don't persist
    setAccessOk(true);
    setCodeDraft('');
  } catch (err) {
    setAccessErr(err.message || 'Invalid code');
  } finally {
    setChecking(false);
  }
}

      // Load FAQ when channel changes
      useEffect(()=>{
        if (!accessOk) return;
        (async ()=>{
          try {
            const md = await fetchFAQMd(channelId);
            setFaqMd(md);
            resetRun(true);
          } catch(e){
            console.error(e);
          }
        })();
      }, [channelId, accessOk]);

      useEffect(()=>{ scrollRef.current?.scrollTo({ top: 999999, behavior: 'smooth' }); }, [messages, typing]);

      function toast(msg){
        setNotice(msg);
        setTimeout(()=>setNotice(''), 1800);
      }

      function resetRun(clearMsgs=true){
        if (timerRef.current) clearInterval(timerRef.current);
        setStarted(false); setFinished(false);
        setQCount(0); setSecondsLeft(RUN_SECONDS);
        setHistory([]); setGrading(null);
        setDraft('');
        if (clearMsgs) setMessages([]);
      }

      function startTimer(){
        timerRef.current = setInterval(()=>{
          setSecondsLeft(prev=>{
            if(prev<=1){
              clearInterval(timerRef.current);
              endRun(); // timer out uses whatever results exist
              return 0;
            }
            return prev-1;
          })
        },1000);
      }

      async function startRun(){
        setStarted(true); setFinished(false); setQCount(0); setGrading(null); setMessages([]);
        setHistory([]);
        startTimer();
        setMessages([{from:'bot', text:"I’ll ask you 5 quick questions. Answer using the FAQs. Ready?", time: now()}]);
        await askNext();
      }

      const mmss = s => `${String(Math.floor(s/60)).padStart(2,'0')}:${String(s%60).padStart(2,'0')}`;

      async function askNext(){
        if (qCount >= QUESTIONS_PER_RUN) { endRun(); return; }
        setTyping(true);
        try{
          const reply = await coachAsk({ history, channelId, faqMd });
          const text = reply?.content?.trim() || "Ask: (No coach output)";
          setMessages(m=>[...m, {from:'bot', text, time: now()}]);
          setHistory(h=>[...h, {role:'assistant', content:text}]);
        } catch (e) {
          setMessages(m=>[...m, {from:'bot', text:`Coach error: ${e.message}`, time: now()}]);
        } finally {
          setTyping(false);
        }
      }

      // End run; also unlock next channel if this one is fully answered
      function endRun(passedResults){
        if (finished) return;
        if (timerRef.current) clearInterval(timerRef.current);
        setFinished(true);

        const results = passedResults ?? (grading?.results || []);
        const total = results.filter(r=>r.passed).length;
        const pct = Math.round(((total||0)/QUESTIONS_PER_RUN)*100);

        setMessages(m=>[...m, {from:'bot', text:`Test complete. You scored ${total||0}/${QUESTIONS_PER_RUN} (${pct}%).`, time: now()}]);

        // Unlock next channel ONLY if all 5 were answered (regardless of score)
        const answeredAll = (results.length >= QUESTIONS_PER_RUN);
        if (answeredAll) {
          setCompletedIds(prev => new Set(prev).add(channelId));
          const currentIdx = CHANNELS.findIndex(c => c.id === channelId);
          setUnlockedIdx(prev => Math.max(prev, Math.min(currentIdx + 1, CHANNELS.length - 1)));
        }
      }

      async function submit(){
        if (!draft.trim() || !started || finished) return;
        const userText = draft.trim();
        setDraft('');
        setMessages(m=>[...m, {from:'user', text:userText, time: now()}]);
        setHistory(h=>[...h, {role:'user', content:userText}]);

        const lastQuestion = [...messages].reverse().find(m=>m.from==='bot')?.text || 'Coach question';

        try {
          const result = await gradeAnswer({ channelId, question:lastQuestion, answer:userText, faqMd });

          const nextCount = qCount + 1;
          setQCount(nextCount);

          setGrading(g=>{
            const prev = g?.results || [];
            const cur = { qText:lastQuestion, ans:userText, ...result };
            const nextResults = [...prev, cur];

            if (nextCount >= QUESTIONS_PER_RUN) {
              endRun(nextResults);
            } else {
              askNext();
            }
            return { results: nextResults };
          });

        } catch (e) {
          const nextCount = qCount + 1;
          setQCount(nextCount);

          setGrading(g=>{
            const prev = g?.results || [];
            const cur = { qText:lastQuestion, ans:userText, passed:false, why:`Grader error: ${e.message}`, matched:[], missing:[], flags:[] };
            const nextResults = [...prev, cur];

            if (nextCount >= QUESTIONS_PER_RUN) {
              endRun(nextResults);
            } else {
              askNext();
            }
            return { results: nextResults };
          });
        }
      }

      // Click handler with locking rules
      function trySwitchChannel(targetId, targetIdx){
        if (started && !finished) {
          toast("Finish this run before switching channels.");
          return;
        }
        const locked = targetIdx > unlockedIdx;
        if (locked) {
          toast("Locked. Complete the previous channel first.");
          return;
        }
        setChannelId(targetId);
      }

      // If not unlocked by access code yet, show gate screen and stop
      if (!accessOk) {
        return (
          <div className="min-h-screen grid place-items-center bg-slate-100 p-4">
            <form onSubmit={handleAccessSubmit} className="w-full max-w-sm bg-white border rounded-2xl p-5 shadow-sm">
              <div className="text-center mb-4">
                <h1 className="text-lg font-semibold text-slate-800">Enter Access Code</h1>
                <p className="text-xs text-slate-500 mt-1">Ask your trainer for today’s code.</p>
              </div>
              <input
                className="w-full border rounded px-3 py-2"
                placeholder="Access code"
                value={codeDraft}
                onChange={e=>setCodeDraft(e.target.value)}
                autoFocus
              />
              {accessErr && <div className="text-rose-600 text-xs mt-2">{accessErr}</div>}
              <button
                type="submit"
                className="w-full mt-3 px-3 py-2 rounded bg-indigo-600 text-white disabled:opacity-50"
                disabled={checking || !codeDraft.trim()}>
                {checking ? 'Checking…' : 'Unlock'}
              </button>
              <div className="text-[10px] text-slate-400 mt-3">Apex Trader Funding • Access Gate</div>
            </form>
          </div>
        );
      }

      // Render main app after access
      return (
        <div className="grid grid-cols-12 min-h-screen">
          {/* Sidebar */}
          <aside className="col-span-2 hidden md:flex flex-col bg-slate-900 text-slate-200 p-3 gap-3">
            <div className="text-xs uppercase tracking-widest text-slate-400">Channels</div>
            <div className="space-y-1">
              {CHANNELS.map((ch, idx)=>{
                const isActive = channelId===ch.id;
                const locked = idx > unlockedIdx;
                return (
                  <div key={ch.id}
                       className={`ch-item ${isActive?'active hover:bg-slate-800':'hover:bg-slate-800/60'} ${locked?'opacity-40 cursor-not-allowed':''}`}
                       onClick={()=>trySwitchChannel(ch.id, idx)}
                       title={locked ? 'Locked until you complete the previous channel.' : ''}>
                    <span className={`dot ${ch.dot}`}></span>
                    <span className="truncate">{ch.name}</span>
                    {completedIds.has(ch.id) && <span className="ml-auto text-[10px] px-1 py-0.5 rounded bg-emerald-600/20 text-emerald-300">done</span>}
                    {locked && !completedIds.has(ch.id) && <span className="ml-auto text-[10px] px-1 py-0.5 rounded bg-slate-700 text-slate-300">locked</span>}
                  </div>
                );
              })}
            </div>
            <div className="mt-2 h-5 text-xs text-amber-300">{notice}</div>
            <div className="mt-auto text-[10px] text-slate-500">Apex Trader Funding • Vercel Functions</div>
          </aside>

          {/* Main */}
          <main className="col-span-12 md:col-span-10 p-4 md:p-6 grid gap-3 content-start">
            <div className="flex items-center justify-between">
              <div className="flex items-center gap-2 text-slate-700">
                <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" viewBox="0 0 24 24" fill="currentColor"><path d="M11.5 2a.75.75 0 0 1 .7.48l1.26 3.29 3.3 1.26a.75.75 0 0 1 0 1.4l-3.3 1.26-1.26 3.3a.75.75 0 0 1-1.4 0l-1.26-3.3-3.3-1.26a.75.75 0 0 1 0-1.4l3.3-1.26 1.26-3.3a.75.75 0 0 1 .7-.48Z"/></svg>
                <h1 className="text-xl font-semibold">Apex Trader Funding</h1>
                <span className="text-xs bg-slate-200 text-slate-700 px-2 py-0.5 rounded">{CHANNELS.find(c=>c.id===channelId)?.name}</span>
              </div>
              <div className="flex items-center gap-3">
                <div className={`text-sm font-semibold text-slate-700 ${started&&!finished?'':'hidden'}`}>{mmss(secondsLeft)}</div>
                {!started && <button className="px-3 py-1.5 rounded bg-indigo-600 text-white hover:bg-indigo-500" onClick={startRun}
                  disabled={CHANNELS.findIndex(c=>c.id===channelId) > unlockedIdx}
                  title={CHANNELS.findIndex(c=>c.id===channelId) > unlockedIdx ? 'Locked channel' : ''}>
                  Start
                </button>}
                <button className="px-3 py-1.5 rounded border border-slate-300 hover:bg-white" onClick={()=>resetRun()}>Reset</button>
              </div>
            </div>

            <div className="border rounded-xl overflow-hidden bg-white">
              <div className="px-4 py-3 border-b text-sm text-slate-500">
                {started ? "Answer 5 questions before the timer runs out." : "Press Start at the top rigth to begin."}
              </div>
              <div className="bg-slate-50 p-3 h-[52vh] overflow-y-auto flex flex-col gap-4" ref={scrollRef}>
                {messages.map((m,i)=><Row key={i} from={m.from} text={m.text} time={m.time} />)}
                {typing && <div className="text-xs text-slate-500">Coach is typing…</div>}
                {!started && <div className="text-xs text-slate-600">You will be given 10 minutes to complete all 5 questions and unlock the next channel.</div>}
              </div>
              <div className="px-4 py-3 border-t bg-white flex items-center justify-between">
                <div className="text-xs text-slate-500">
                  {started && !finished ? `${qCount}/${QUESTIONS_PER_RUN} answered` : ''}
                </div>
                <div className="flex gap-2 items-center w-2/3">
                  <input className="border rounded px-3 py-1.5 w-full"
                         placeholder={started && !finished ? "Type your reply and press Enter…" : "Start the run to reply…"}
                         value={draft}
                         onChange={e=>setDraft(e.target.value)}
                         onKeyDown={e=>{ if(e.key==="Enter" && !e.shiftKey){ e.preventDefault(); submit(); } }}
                         disabled={!started || finished}/>
                  <button className="px-3 py-1.5 rounded bg-emerald-600 text-white disabled:opacity-50"
                          disabled={!started || finished || !draft.trim()} onClick={submit}>Send</button>
                </div>
              </div>
            </div>

            {grading && grading.results && grading.results.length>0 && (
              <div className="border rounded-xl bg-white">
                <div className="px-4 py-3 border-b flex items-center justify-between">
                  <div>
                    <div className="text-sm text-slate-500">Results</div>
                    <div className="text-lg font-semibold">
                      {(grading.results.filter(r=>r.passed).length)}/{QUESTIONS_PER_RUN} correct
                    </div>
                  </div>
                  <div className="text-xs text-slate-500">Passing requires good coverage & no incorrect claims.</div>
                </div>
                <div className="p-4 space-y-3">
                  {grading.results.map((r,idx)=>(
                    <div key={idx} className="rounded-xl border p-3 bg-slate-50">
                      <div className="text-xs text-slate-500 mb-1">Question: {r.qText}</div>
                      <div className="text-sm font-medium">Q{idx+1} • {r.passed ? <span className="text-emerald-600">Correct</span> : <span className="text-rose-600">Needs Work</span>}</div>
                      <div className="mt-2 text-sm">
                        <div className="text-slate-500 mb-1">Your reply:</div>
                        <div className="bg-white rounded-lg border p-3 text-slate-700">{r.ans || r.answer}</div>
                      </div>
                      <div className="mt-2 text-xs text-slate-600 space-y-1">
                        {r.matched?.length>0 && <div>Matched: {r.matched.join(', ')}</div>}
                        {r.missing?.length>0 && <div>Missing: {r.missing.join(', ')}</div>}
                        {r.flags?.length>0 && <div className="text-rose-600">Flags: {r.flags.join(', ')}</div>}
                        {r.why && <div className="italic text-slate-700">Why: {r.why}</div>}
                      </div>
                    </div>
                  ))}
                </div>
              </div>
            )}
          </main>
        </div>
      );
    }

    ReactDOM.createRoot(document.getElementById('root')).render(<App />);
  </script>
</body>
</html>
